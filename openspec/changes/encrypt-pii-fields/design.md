# PII暗号化設計

## Context
のびレコアプリケーションでは、個人識別情報（PII）をデータベースに保存する必要があります。セキュリティ要件（`docs/00_nonfunctional_requirements_review.md`）に従い、以下のPIIフィールドを暗号化する必要があります：

### 暗号化対象フィールド

#### m_guardiansテーブル
- `phone` - 電話番号
- `email` - メールアドレス
- `postal_code` - 郵便番号
- `address` - 住所
- `notes` - 特記事項
- `family_name` - 姓（漢字）
- `given_name` - 名（漢字）
- `family_name_kana` - 姓（カナ）
- `given_name_kana` - 名（カナ）

#### m_childrenテーブル
- `parent_phone` - 保護者電話番号（DEPRECATED、後方互換性のため暗号化）
- `parent_email` - 保護者メールアドレス（DEPRECATED、後方互換性のため暗号化）
- `allergies` - アレルギー情報
- `health_notes` - 健康に関する特記事項
- `child_characteristics` - 子どもの基本特性
- `parent_characteristics` - 親の特性・要望
- `family_name` - 姓（漢字）
- `given_name` - 名（漢字）
- `family_name_kana` - 姓（カナ）
- `given_name_kana` - 名（カナ）

## Goals / Non-Goals

### Goals
- AES-256-GCMアルゴリズムを使用したPIIフィールドの暗号化
- 既存のAPIエンドポイントとの互換性維持（透過的な暗号化/復号化）
- パフォーマンスへの影響を最小限に抑制
- 暗号化キーの安全な管理

### Non-Goals
- 既存データの自動移行（手動移行スクリプトを提供）
- データベースレベルの暗号化（アプリケーションレベルで実装）
- 検索インデックスの暗号化対応（検索機能への影響を最小限に）

## Decisions

### Decision 1: 暗号化アルゴリズム
**選択**: AES-256-GCM

**理由**:
- セキュリティ要件で指定されている
- 認証付き暗号化（AEAD）により改ざん検出が可能
- 既存の`childIdEncryption.ts`と同じアルゴリズムで一貫性を保つ

**代替案**:
- AES-256-CBC: 認証タグがないため改ざん検出不可
- ChaCha20-Poly1305: 要件で指定されていない

### Decision 2: 暗号化キーの管理
**選択**: 環境変数`PII_ENCRYPTION_KEY`（64文字の16進数文字列、32バイト）

**理由**:
- 既存の`CHILD_ID_ENCRYPTION_KEY`と同じパターンで一貫性を保つ
- 環境ごとに異なるキーを設定可能
- キーローテーションが容易

**代替案**:
- AWS KMS / Google Cloud KMS: インフラ依存が増える
- データベース内のキー管理: セキュリティリスクが高い

### Decision 3: 暗号化ユーティリティの設計
**選択**: 汎用的な`encryptPII`/`decryptPII`関数を提供

**理由**:
- 複数のフィールドタイプ（電話番号、メールアドレス、テキスト）に対応
- コードの重複を避ける
- テストが容易

**実装パターン**:
```typescript
// 暗号化
const encrypted = encryptPII(plaintext: string): string | null

// 復号化
const decrypted = decryptPII(encrypted: string): string | null
```

### Decision 4: 検索機能への影響と検索用ハッシュテーブル
**選択**: 検索用ハッシュテーブル（`s_pii_search_index`）を導入

**必要性の詳細**:

1. **兄弟紐づけ機能での電話番号検索**
   - `app/api/children/search-siblings/route.ts`で電話番号による検索が必須
   - 現在は全児童を取得してから`parent_phone`でフィルタリング（70-73行目）
   - 暗号化されると、全件取得→全件復号化→比較が必要になり、非効率
   - **検索用ハッシュテーブル必須**

2. **名前による部分一致検索（一覧画面）**
   - `app/api/children/route.ts`で`family_name.ilike.%${search}%`などの部分一致検索が存在（92行目）
   - 暗号化された値では`ilike`検索が不可能
   - 検索用テーブルに正規化された値を保存し、`ilike`で検索する必要がある
   - **検索用ハッシュテーブル必須**

3. **CSVインポート時の兄弟検索**
   - `app/api/children/import/route.ts`で`m_guardians`テーブルから電話番号で検索（15-34行目）
   - 暗号化されると検索が困難
   - **検索用ハッシュテーブル必須**

4. **メンション機能（検索用ハッシュテーブル不要）**
   - `app/records/activity/activity-record-client.tsx`では、`/api/children?class_id=${classId}`でクラスの全児童を事前取得（312行目）
   - その後、クライアント側で文字検索しているため、データベースでの検索は不要
   - 取得時に復号化された名前が返されるため、メンション機能は問題なく動作する
   - **検索用ハッシュテーブル不要**

**理由**:
- 暗号化された値では部分一致検索（`ilike`）が不可能
- 全件取得→復号化→比較は非効率（特に児童数が多い場合、100件で10-50ms追加）
- 兄弟紐づけ機能で電話番号による検索が必須
- 名前による部分一致検索（`family_name.ilike.%${search}%`）が多数存在

**検索用ハッシュテーブルの設計**:
```sql
CREATE TABLE s_pii_search_index (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_type VARCHAR(20) NOT NULL,  -- 'child' or 'guardian'
  entity_id UUID NOT NULL,            -- m_children.id or m_guardians.id
  search_type VARCHAR(20) NOT NULL,   -- 'phone', 'email', 'name', 'name_kana'
  search_hash VARCHAR(64) NOT NULL,   -- SHA-256ハッシュ（検索用）
  normalized_value TEXT,              -- 正規化された値（完全一致検索用）
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(entity_type, entity_id, search_type)
);
```

**検索パターン**:
- **電話番号・メールアドレス**: SHA-256ハッシュで完全一致検索
- **名前（部分一致検索）**: 正規化された値（`normalized_value`）で`ilike`検索
  - 一覧画面での検索に使用（`/api/children?search=...`）
  - メンション機能は事前取得したリストからクライアント側で検索するため、検索用ハッシュテーブルは不要

**実装方針**:
- 保存時に検索用ハッシュテーブルも更新
- 検索時は検索用テーブルから`entity_id`を取得し、本体テーブルから詳細情報を取得

### Decision 5: 後方互換性とデータ移行
**選択**: 更新時に暗号化形式に変換（既存データは更新時に自動移行）

**理由**:
- 既存データの一括移行はリスクが高い
- 更新時に自動的に暗号化形式に変換することで、段階的に移行
- 読み取り時に復号化失敗時は平文として扱う（後方互換性）

**移行戦略**:
1. 新規データは暗号化して保存
2. 既存データは読み取り時に復号化を試み、失敗した場合は平文として扱う
3. **更新時に暗号化形式に変換**（保存処理で自動的に暗号化）
4. 検索用ハッシュテーブルも更新時に同期して更新

## Risks / Trade-offs

### Risk 1: パフォーマンスへの影響
**リスク**: 暗号化/復号化のオーバーヘッドにより、API応答時間が増加

**緩和策**:
- 暗号化/復号化は非同期処理で並列化可能な箇所は並列化
- パフォーマンステストを実施し、許容範囲内であることを確認
- 必要に応じてキャッシュを導入

### Risk 2: 暗号化キーの漏洩
**リスク**: 環境変数が漏洩した場合、すべてのPIIが復号可能

**緩和策**:
- 環境変数は機密情報として管理（Supabase Secrets、環境変数管理サービス）
- 定期的なキーローテーション手順をドキュメント化
- アクセスログの監視

### Risk 3: 既存データの移行失敗
**リスク**: 移行スクリプトの実行中にエラーが発生し、データが破損

**緩和策**:
- 移行前にバックアップを取得
- 移行スクリプトはトランザクション内で実行
- ロールバック手順を用意

### Risk 4: 検索機能のパフォーマンス
**リスク**: 検索用ハッシュテーブルの追加により、保存処理が複雑化

**緩和策**:
- 検索用ハッシュテーブルの更新は、本体テーブルの更新と同一トランザクション内で実行
- インデックスを適切に設定して検索性能を確保
- バッチ処理で検索用テーブルを再構築する機能を提供（必要に応じて）

## Migration Plan

### Phase 1: 実装（新規データのみ暗号化）
1. 暗号化ユーティリティを実装
2. 保存処理に暗号化を適用
3. 読み取り処理に復号化を適用（失敗時は平文として扱う）
4. テストを実施

### Phase 2: 既存データの移行（オプション）
1. 移行スクリプトを作成
2. ステージング環境でテスト
3. 本番環境でバックアップを取得
4. 移行スクリプトを実行
5. データ整合性を確認

### Rollback Plan
- 新規データのみ暗号化している場合: コードをロールバックし、新規データも平文で保存
- 既存データも移行済みの場合: 移行前のバックアップから復元

## パフォーマンス分析

### 暗号化/復号化のオーバーヘッド
- **AES-256-GCMの性能**: 1バイトあたり数ナノ秒（非常に高速）
- **典型的なAPI応答時間**: 100-500ms
- **暗号化/復号化のオーバーヘッド**: 
  - 電話番号（20文字）: 約0.1ms
  - メールアドレス（50文字）: 約0.2ms
  - 名前（100文字）: 約0.5ms
  - テキストフィールド（1000文字）: 約5ms

### 影響評価
- **単一レコードの保存/読み取り**: オーバーヘッドは無視できるレベル（1-10ms程度）
- **一覧取得（100件）**: 復号化処理で10-50ms程度の追加（許容範囲内）
- **全件取得→復号化→比較**: 非効率（検索用ハッシュテーブルで回避）

### 結論
パフォーマンスへの影響は**最小限**。検索用ハッシュテーブルを導入することで、検索性能も維持可能。

## Open Questions

1. **キーローテーション**: 定期的なキーローテーションを実装するか、手動で対応するか？
2. **監査ログ**: 暗号化/復号化の実行ログを記録するか？（セキュリティ監査のため）
3. **検索用ハッシュテーブルのメンテナンス**: 定期的な再構築が必要か？
